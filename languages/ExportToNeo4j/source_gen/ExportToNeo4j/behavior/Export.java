package ExportToNeo4j.behavior;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.neo4j.driver.v1.Driver;
import org.neo4j.driver.v1.GraphDatabase;
import org.neo4j.driver.v1.AuthTokens;
import org.neo4j.driver.v1.Statement;
import org.neo4j.driver.v1.Session;
import org.neo4j.driver.v1.TransactionWork;
import org.neo4j.driver.v1.Transaction;
import org.neo4j.driver.v1.StatementResult;
import org.neo4j.driver.v1.exceptions.ClientException;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import org.jetbrains.mps.openapi.module.SModule;
import org.neo4j.driver.v1.Values;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class Export implements AutoCloseable {
  private static final Logger LOG = LogManager.getLogger(Export.class);
  private final Driver driver;

  public Export(String uri, String user, String password) {
    driver = GraphDatabase.driver(uri, AuthTokens.basic(user, password));
  }
  @Override
  public void close() throws Exception {
  }
  private String executeStatement(final Statement statement) {
    Session session = driver.session();
    return session.writeTransaction(new TransactionWork<String>() {
      @Override
      public String execute(Transaction tx) {
        try {
          StatementResult result = tx.run(statement);
          if (result.hasNext()) {
            return result.next().get(0).asString();
          }
          return null;
        } catch (ClientException clientException) {
          LoggingRuntime.logMsgView(Level.WARN, "Client Exception", Export.class, clientException, null);
          return null;
        }
      }
    });
  }

  public void setUniqueConstraintNodeId() {
    Statement statement = new Statement("CREATE CONSTRAINT ON (node:Node) ASSERT node.nodeid IS UNIQUE");
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return unique constraint id " + returnmessage, Export.class, null, null);
  }

  public void exportModule(final SModule sModule) {
    final Statement statement = new Statement("MERGE (m:Module{moduleid:$moduleid}) SET m.name = $name RETURN ' module ' + id(m)", Values.parameters("name", sModule.getModuleName(), "moduleid", sModule.getModuleId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return module id " + returnmessage, Export.class, null, null);
  }

  public void exportModel(final SModel model) {
    Statement statement = new Statement("MERGE (m:Model{modelid:$modelid}) SET m.name = $name RETURN ' model ' + id(m)", Values.parameters("name", SModelOperations.getModelName(model), "modelid", model.getModelId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return model id " + returnmessage, Export.class, null, null);
  }

  public void AddLabelNode(final SNode node, final String label) {
    Statement statement = new Statement("MATCH (a:Node{nodeid:$nodeid}) SET a:" + label + " RETURN ' node ' + id(a)", Values.parameters("nodeid", node.getNodeId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return node id with new label" + returnmessage, Export.class, null, null);
  }


  public void exportNode(final SNode node) {
    Session session = driver.session();
    String returnmessage = session.writeTransaction(new TransactionWork<String>() {
      @Override
      public String execute(Transaction tx) {
        {
          final SNode namedConcept = node;
          if (SNodeOperations.isInstanceOf(namedConcept, CONCEPTS.INamedConcept$nV)) {
            try {
              StatementResult result = tx.run("MERGE (a:Node{nodeid:$nodeid}) SET a.name = $name RETURN ' node ' + id(a)", Values.parameters("name", SPropertyOperations.getString(namedConcept, PROPS.name$tAp1), "nodeid", namedConcept.getNodeId().toString(), "label", SNodeOperations.getConcept(namedConcept).getName()));
              return result.next().get(0).asString();
            } catch (ClientException clientException) {
              LoggingRuntime.logMsgView(Level.WARN, "Client Exception", Export.class, clientException, null);
              return null;
            }
          }
        }
        return null;
      }
    });
    LoggingRuntime.logMsgView(Level.INFO, "Return node id " + returnmessage, Export.class, null, null);

    final Language l = SModelUtil.getDeclaringLanguage(SNodeOperations.getConceptDeclaration(node));
    Statement statement = new Statement("MATCH (n:Node) WHERE n.nodeid = $nodeid SET n.language = $language", Values.parameters("nodeid", node.getNodeId().toString(), "language", l.toString()));
    String returnmessage2 = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "language property added " + returnmessage2, Export.class, null, null);

    if (l.isReadOnly() == false) {
      // create declaration node too. 
      Statement statement3 = new Statement("MERGE (a:Node{nodeid:$nodeid}) SET a.name = $name RETURN ' node ' + id(a)", Values.parameters("nodeid", SNodeOperations.getConcept(node).getDeclarationNode().getNodeId().toString(), "name", SNodeOperations.getConcept(node).getName()));
      String returnmessage3 = executeStatement(statement3);
      LoggingRuntime.logMsgView(Level.INFO, "concept declaration added " + returnmessage3, Export.class, null, null);
    }

    exportRelation(node, SNodeOperations.getConcept(node).getDeclarationNode(), "basedOn");
    AddLabelNode(node, SNodeOperations.getConcept(node).getName());
  }

  public void exportModuleContains(final SModule sModule, final SModel model, final String type) {
    Statement statement = new Statement("MATCH (m:Module), (n:Model) WHERE m.moduleid = $moduleid AND n.modelid = $modelid MERGE (m)-[r:" + type + "]->(n) RETURN 'relation id ' + id(r)", Values.parameters("moduleid", sModule.getModuleId().toString(), "modelid", model.getModelId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return module contains " + returnmessage, Export.class, null, null);
  }

  public void exportModelContains(final SModel model, final SNode node, final String type) {
    Statement statement = new Statement("MATCH (m:Model), (n:Node) WHERE m.modelid = $modelid AND n.nodeid = $nodeid MERGE (m)-[r:" + type + "]->(n) RETURN 'relation id ' + id(r)", Values.parameters("modelid", model.getModelId().toString(), "nodeid", node.getNodeId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return model contains " + returnmessage, Export.class, null, null);
  }
  public void exportRelation(final SNode fromNode, final SNode toNode, final String type) {
    Statement statement = new Statement("MATCH (n1:Node), (n2:Node) WHERE n1.nodeid = $nodeid1 AND n2.nodeid = $nodeid2 MERGE (n1)-[r:" + type + "]->(n2) RETURN 'relation id ' + id(r)", Values.parameters("nodeid1", fromNode.getNodeId().toString(), "nodeid2", toNode.getNodeId().toString()));
    String returnmessage = executeStatement(statement);
    LoggingRuntime.logMsgView(Level.INFO, "Return relation " + returnmessage, Export.class, null, null);
  }

  public void exportModuleAndContents(final SModule sModule) {
    exportModule(sModule);
    for (SModel model : Sequence.fromIterable(sModule.getModels())) {
      exportModel(model);
      exportModuleContains(sModule, model, "contains");
      for (SNode rootnode : Sequence.fromIterable(model.getRootNodes())) {
        exportNode(rootnode);
        exportModelContains(model, rootnode, "contains");
        exportChilds(rootnode);
        exportReferences(rootnode);
      }
    }
  }
  public void exportChilds(final SNode node) {
    for (SNode child : Sequence.fromIterable(node.getChildren())) {
      exportNode(child);
      exportProperties(child);
      exportRelation(node, child, "child");
      exportReferences(child);
      exportChilds(child);
    }
  }
  public void exportReferences(final SNode node) {
    for (SReference reference : Sequence.fromIterable(node.getReferences())) {
      exportNode(reference.getTargetNode());
      exportRelation(node, reference.getTargetNode(), "reference");
    }
  }

  public void exportProperties(final SNode node) {
    for (SProperty property : Sequence.fromIterable(node.getProperties())) {
      LoggingRuntime.logMsgView(Level.INFO, "Property " + property.getName(), Export.class, null, null);
      Statement statement = new Statement("MATCH (n:Node) WHERE n.nodeid = $nodeid SET n." + property.getName() + " = $value RETURN ' node ' + id(n )", Values.parameters("value", node.getProperty(property).toString(), "nodeid", node.getNodeId().toString()));
      String returnmessage = executeStatement(statement);
      LoggingRuntime.logMsgView(Level.INFO, "Return property " + returnmessage, Export.class, null, null);
    }
  }

  public static void main(SModule sModule) {
    Export example = new Export("bolt://localhost:7687", "neo4j", "Password");
    example.setUniqueConstraintNodeId();
    example.exportModuleAndContents(sModule);
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept INamedConcept$nV = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$tAp1 = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
